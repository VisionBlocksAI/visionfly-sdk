{"version":3,"file":"index.js","sources":["../src/visionfly-core.js"],"sourcesContent":["/**\n * VisionFly - Lightweight Image Optimization SDK\n * @version 1.0.0\n */\n\n/**\n * Core VisionFly client\n */\nclass VisionFly {\n  /**\n   * Initialize VisionFly SDK\n   * @param {Object} config - Configuration options\n   * @param {string} config.apiKey - Your VisionFly API key\n   * @param {string} config.apiSecret - Your VisionFly API secret\n   * @param {string} [config.baseUrl='https://api.visionfly.ai'] - Base API URL\n   * @param {string} [config.cdnUrl='https://cdn.visionfly.ai'] - CDN URL\n   */\n  constructor({\n    apiKey,\n    apiSecret,\n    baseUrl = \"https://api.visionfly.ai\",\n    cdnUrl = \"https://cdn.visionfly.ai\",\n  }) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.baseUrl = baseUrl;\n    this.cdnUrl = cdnUrl;\n    this.token = null;\n    this.tokenExpiry = null;\n    this.refreshToken = null;\n\n    // Cache for transformed URLs\n    this.urlCache = new Map();\n  }\n\n  /**\n   * Internal method to handle authentication\n   * @private\n   */\n  async _ensureAuthenticated() {\n    // If token exists and is valid, return\n    if (this.token && this.tokenExpiry && this.tokenExpiry > Date.now()) {\n      return;\n    }\n\n    // If token expired or not set, authenticate\n    await this._authenticate();\n  }\n\n  /**\n   * Authenticate with the API\n   * @private\n   */\n  async _authenticate() {\n    try {\n      const response = await fetch(`${this.baseUrl}/auth/login`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          api_key: this.apiKey,\n          api_secret: this.apiSecret,\n        }),\n      });\n\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.msg || \"Authentication failed\");\n      }\n\n      const data = await response.json();\n      this.token = data.access_token;\n      this.refreshToken = data.refresh_token;\n      // Set expiry 5 minutes before actual expiry as a buffer\n      this.tokenExpiry = Date.now() + data.expires_in * 1000 - 5 * 60 * 1000;\n    } catch (error) {\n      console.error(\"VisionFly authentication error:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh the auth token\n   * @private\n   */\n  async _refreshToken() {\n    try {\n      const response = await fetch(`${this.baseUrl}/auth/refresh`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          refresh_token: this.refreshToken,\n        }),\n      });\n\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.msg || \"Token refresh failed\");\n      }\n\n      const data = await response.json();\n      this.token = data.access_token;\n      this.refreshToken = data.refresh_token;\n      this.tokenExpiry = Date.now() + data.expires_in * 1000 - 5 * 60 * 1000;\n    } catch (error) {\n      console.error(\"VisionFly token refresh error:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Make an authenticated request to the API\n   * @private\n   * @param {string} endpoint - API endpoint\n   * @param {Object} options - Fetch options\n   * @returns {Promise<Object>} Response data\n   */\n  async _request(endpoint, options = {}) {\n    await this._ensureAuthenticated();\n\n    const defaultOptions = {\n      headers: {\n        Authorization: `Bearer ${this.token}`,\n      },\n    };\n\n    const fullOptions = {\n      ...defaultOptions,\n      ...options,\n      headers: {\n        ...defaultOptions.headers,\n        ...options.headers,\n      },\n    };\n\n    try {\n      let response = await fetch(`${this.baseUrl}${endpoint}`, fullOptions);\n\n      // Handle token expiration\n      if (response.status === 401) {\n        await this._refreshToken();\n        fullOptions.headers.Authorization = `Bearer ${this.token}`;\n        response = await fetch(`${this.baseUrl}${endpoint}`, fullOptions);\n      }\n\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(\n          error.msg || `Request failed with status ${response.status}`\n        );\n      }\n\n      return response.json();\n    } catch (error) {\n      console.error(\"VisionFly request error:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get a CDN URL for an image with transformations\n   * @param {Object} params - Transformation parameters\n   * @param {string} params.src - Source image URL\n   * @param {number} [params.width] - Width in pixels\n   * @param {number} [params.height] - Height in pixels\n   * @param {number} [params.quality=80] - Image quality (1-100)\n   * @param {string} [params.format='auto'] - Output format (auto, webp, avif, jpeg, png)\n   * @param {number} [params.blur] - Blur amount (0-100)\n   * @param {number} [params.sharpen] - Sharpen amount (0-100)\n   * @param {number} [params.brightness] - Brightness adjustment (-100 to 100)\n   * @param {number} [params.contrast] - Contrast adjustment (-100 to 100)\n   * @param {number} [params.saturation] - Saturation adjustment (-100 to 100)\n   * @param {number} [params.hue] - Hue rotation (0-360)\n   * @returns {Promise<string>} CDN URL\n   */\n  async getImageUrl(params) {\n    // Generate a cache key from the params\n    const cacheKey = JSON.stringify(params);\n\n    // Check cache first\n    if (this.urlCache.has(cacheKey)) {\n      return this.urlCache.get(cacheKey);\n    }\n\n    // Build query for the API\n    const apiParams = new URLSearchParams();\n\n    // Map user-friendly param names to API param names\n    const paramMap = {\n      src: \"src\",\n      width: \"w\",\n      height: \"h\",\n      quality: \"q\",\n      format: \"f\",\n      blur: \"blur\",\n      sharpen: \"sharp\",\n      brightness: \"bri\",\n      contrast: \"con\",\n      saturation: \"sat\",\n      hue: \"hue\",\n    };\n\n    // Add all params to query\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        const apiKey = paramMap[key] || key;\n        apiParams.append(apiKey, value);\n      }\n    });\n\n    // Get the transformed URL from the API\n    const endpoint = `/transform?${apiParams.toString()}`;\n    const result = await this._request(endpoint);\n\n    if (!result.public_url) {\n      throw new Error(\"Transform API did not return a public_url\");\n    }\n\n    // Cache the result\n    this.urlCache.set(cacheKey, result.public_url);\n\n    return result.public_url;\n  }\n\n  /**\n   * Generate a responsive srcset for an image\n   * @param {Object} params - Srcset parameters\n   * @param {string} params.src - Source image URL\n   * @param {Array<number>|string} [params.widths=[400,800,1200]] - Array or comma-separated string of widths\n   * @param {string} [params.format='auto'] - Output format\n   * @param {number} [params.quality=80] - Image quality\n   * @returns {Promise<Object>} Srcset data with processed URLs\n   */\n  async getSrcSet(params) {\n    const {\n      src,\n      widths = [400, 800, 1200],\n      format = \"auto\",\n      quality = 80,\n    } = params;\n\n    // Convert widths array to string if needed\n    const widthsStr = Array.isArray(widths) ? widths.join(\",\") : widths;\n\n    // Get srcset data from API\n    const apiParams = new URLSearchParams({\n      src,\n      w: widthsStr,\n      f: format,\n      q: quality,\n    });\n\n    const srcsetData = await this._request(\n      `/generate/srcset?${apiParams.toString()}`\n    );\n\n    // Process each URL in the srcset to get actual CDN URLs\n    const srcsetParts = srcsetData.srcset.split(\",\").map((part) => part.trim());\n    const processedParts = await Promise.all(\n      srcsetParts.map(async (part) => {\n        // Split part into URL and width descriptor\n        const [url, widthDesc] = part.split(\" \");\n\n        // Parse URL to get transform parameters\n        const urlObj = new URL(url);\n        const transformParams = {};\n\n        // Convert API params back to SDK format\n        const reverseParamMap = {\n          src: \"src\",\n          w: \"width\",\n          h: \"height\",\n          q: \"quality\",\n          f: \"format\",\n          blur: \"blur\",\n          sharp: \"sharpen\",\n          bri: \"brightness\",\n          con: \"contrast\",\n          sat: \"saturation\",\n          hue: \"hue\",\n        };\n\n        // Extract params from URL\n        for (const [key, value] of urlObj.searchParams.entries()) {\n          const paramKey = reverseParamMap[key] || key;\n          transformParams[paramKey] = value;\n        }\n\n        // Get CDN URL for this width\n        const cdnUrl = await this.getImageUrl(transformParams);\n\n        // Return new srcset entry with CDN URL\n        return `${cdnUrl} ${widthDesc}`;\n      })\n    );\n\n    // Process default URL\n    const defaultUrlObj = new URL(srcsetData.default);\n    const defaultParams = {};\n\n    // Convert API params back to SDK format for default URL\n    const reverseParamMap = {\n      src: \"src\",\n      w: \"width\",\n      h: \"height\",\n      q: \"quality\",\n      f: \"format\",\n      blur: \"blur\",\n      sharp: \"sharpen\",\n      bri: \"brightness\",\n      con: \"contrast\",\n      sat: \"saturation\",\n      hue: \"hue\",\n    };\n\n    // Extract params from default URL\n    for (const [key, value] of defaultUrlObj.searchParams.entries()) {\n      const paramKey = reverseParamMap[key] || key;\n      defaultParams[paramKey] = value;\n    }\n\n    // Get CDN URL for default\n    const defaultCdnUrl = await this.getImageUrl(defaultParams);\n\n    // Return processed srcset data\n    return {\n      srcset: processedParts.join(\", \"),\n      sizes: srcsetData.sizes,\n      default: defaultCdnUrl,\n    };\n  }\n\n  /**\n   * Upload an image to VisionFly\n   * @param {Object} params - Upload parameters\n   * @param {File|Blob} params.file - Image file to upload\n   * @param {string} params.projectId - Project ID\n   * @param {string} [params.publicId] - Optional custom public ID\n   * @returns {Promise<Object>} Upload result\n   */\n  async uploadImage(params) {\n    const { file, projectId, publicId } = params;\n\n    // Create form data\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    formData.append(\"project_id\", projectId);\n\n    if (publicId) {\n      formData.append(\"public_id\", publicId);\n    }\n\n    // Upload the image\n    return this._request(\"/upload/\", {\n      method: \"POST\",\n      body: formData,\n      // Don't set Content-Type header for FormData\n      headers: {},\n    });\n  }\n\n  /**\n   * Clear URL cache\n   */\n  clearCache() {\n    this.urlCache.clear();\n  }\n}\n\nexport { VisionFly };\n"],"names":["constructor","apiKey","apiSecret","baseUrl","cdnUrl","this","token","tokenExpiry","refreshToken","urlCache","Map","_ensureAuthenticated","Date","now","_authenticate","response","fetch","method","headers","body","JSON","stringify","api_key","api_secret","ok","error","json","Error","msg","data","access_token","refresh_token","expires_in","console","_refreshToken","_request","endpoint","options","defaultOptions","Authorization","fullOptions","status","getImageUrl","params","cacheKey","has","get","apiParams","URLSearchParams","paramMap","src","width","height","quality","format","blur","sharpen","brightness","contrast","saturation","hue","Object","entries","forEach","key","value","append","toString","result","public_url","set","getSrcSet","widths","widthsStr","Array","isArray","join","w","f","q","srcsetData","srcsetParts","srcset","split","map","part","trim","processedParts","Promise","all","async","url","widthDesc","urlObj","URL","transformParams","reverseParamMap","h","sharp","bri","con","sat","searchParams","defaultUrlObj","default","defaultParams","defaultCdnUrl","sizes","uploadImage","file","projectId","publicId","formData","FormData","clearCache","clear"],"mappings":"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"}